<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Driver Comparison Tool - USOWN Scout</title>
  <style>
    :root {
      --bg: #0b0d12;
      --panel: #121622;
      --panel-2: #0f1320;
      --accent: #3dd6c1;
      --accent-soft: rgba(61, 214, 193, 0.15);
      --text: #f2f5ff;
      --muted: #9aa3b5;
      --border: #1f2534;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --font: "Manrope", "Segoe UI", sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--font);
      background: radial-gradient(120% 120% at 10% 10%, #101527 0%, #080a0f 55%);
      color: var(--text);
      min-height: 100vh;
    }
    .topnav {
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      padding: 12px 28px;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    .topnav a {
      color: var(--muted);
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      padding: 8px 12px;
      border-radius: 8px;
      transition: all 120ms ease;
    }
    .topnav a:hover {
      color: var(--accent);
      background: var(--accent-soft);
    }
    .topnav a.active {
      color: var(--accent);
      background: var(--accent-soft);
    }
    .brand-header {
      text-align: center;
      padding: 40px 20px 30px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, var(--panel-2) 0%, transparent 100%);
    }
    .brand-title {
      font-size: 32px;
      font-weight: 700;
      margin: 0 0 8px;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, var(--accent), #5a8fff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .brand-subtitle {
      color: var(--muted);
      font-size: 15px;
      margin: 0 0 16px;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
    }
    .brand-links {
      display: flex;
      gap: 12px;
      justify-content: center;
      align-items: center;
      font-size: 13px;
    }
    .brand-links a {
      color: var(--accent);
      text-decoration: none;
      transition: opacity 0.2s;
    }
    .brand-links a:hover { opacity: 0.7; }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 30px 20px;
    }
    h1 {
      margin: 0 0 8px;
      letter-spacing: -0.01em;
      font-weight: 700;
      font-size: 28px;
    }
    .intro {
      color: var(--muted);
      font-size: 15px;
      margin-bottom: 30px;
      line-height: 1.5;
    }
    .selector-section {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 30px;
    }
    .selector-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }
    .driver-select {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .driver-select label {
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    select, input {
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      font-size: 14px;
      outline: none;
      font-family: var(--font);
    }
    select:focus, input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
    }
    .driver-input {
      position: relative;
    }
    .driver-input input {
      width: 100%;
    }
    .autocomplete-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 10px 10px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }
    .autocomplete-list.active {
      display: block;
    }
    .autocomplete-item {
      padding: 10px 12px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.1s;
    }
    .autocomplete-item:hover, .autocomplete-item.selected {
      background: var(--accent-soft);
      color: var(--accent);
    }
    .metric-explainer {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin-top: 16px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.6;
    }
    .metric-explainer h4 {
      margin: 0 0 10px;
      font-size: 14px;
      color: var(--text);
    }
    .metric-explainer ul {
      margin: 0;
      padding-left: 20px;
    }
    .metric-explainer li {
      margin-bottom: 6px;
    }
    .metric-explainer strong {
      color: var(--accent);
    }
    .btn {
      background: linear-gradient(135deg, var(--accent), #5a8fff);
      color: #fff;
      border: none;
      border-radius: 10px;
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
      font-family: var(--font);
    }
    .btn:hover {
      transform: translateY(-1px);
      opacity: 0.9;
    }
    .btn:active {
      transform: translateY(0);
    }
    .comparison-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .driver-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      box-shadow: var(--shadow);
    }
    .driver-card h2 {
      margin: 0 0 4px;
      font-size: 22px;
      color: var(--accent);
    }
    .driver-card .seasons {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 16px;
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }
    .stat-row:last-child {
      border-bottom: none;
    }
    .stat-label {
      font-size: 13px;
      color: var(--muted);
    }
    .stat-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
    }
    .stat-value.best {
      color: var(--accent);
      font-weight: 700;
      text-shadow: 0 0 8px var(--accent-soft);
    }
    .chart-section {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 30px;
    }
    .chart-section h3 {
      margin: 0 0 20px;
      font-size: 18px;
    }
    canvas {
      max-width: 100%;
      height: auto;
    }
    .no-comparison {
      text-align: center;
      padding: 60px 20px;
      color: var(--muted);
    }
    .h2h-section {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 30px;
    }
    .h2h-section h3 {
      margin: 0 0 16px;
      font-size: 18px;
    }
    .h2h-grid {
      display: grid;
      gap: 12px;
    }
    .h2h-item {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
    }
    .h2h-item .year {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }
    .h2h-item .matchup {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .h2h-item .driver-name {
      font-size: 14px;
      font-weight: 600;
    }
    .h2h-item .winner {
      color: var(--accent);
    }
    .radar-container {
      max-width: 600px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <nav class="topnav">
    <a href="driver_profiles.html">Driver Profiles</a>
    <a href="masterdoc_table.html">Data Table</a>
    <a href="driver_comparison.html" class="active">Compare Drivers</a>
    <a href="advancement_pathways.html">Advancement Pathways</a>
    <a href="age_analysis.html">Age Analysis</a>
    <a href="statistics_guide.html">Statistics Guide</a>
  </nav>
  
  <div class="brand-header">
    <h1 class="brand-title">USOWN Scout by USOpenWheelNation</h1>
    <p class="brand-subtitle">An analysis of IndyCar prospects utilizing USF Pro Championships race results from 2015-2025.</p>
    <div class="brand-links">
      <a href="https://usopenWheelNation.com" target="_blank" rel="noopener">Visit USOpenWheelNation.com →</a>
      <span style="color: var(--muted);">•</span>
      <a href="mailto:fuhreredward@gmail.com">Contact: fuhreredward@gmail.com</a>
    </div>
  </div>

  <div class="container">
    <h1>Driver Comparison Tool</h1>
    <p class="intro">
      Compare up to 4 drivers side-by-side. Select drivers from the dropdowns below, then click "Compare" to see detailed stats, career trajectories, and head-to-head matchups when they were teammates.
    </p>

    <div class="selector-section">
      <div class="selector-grid">
        <div class="driver-select">
          <label>Driver 1</label>
          <div class="driver-input">
            <input type="text" id="driver1" placeholder="Type driver name..." autocomplete="off" />
            <div class="autocomplete-list" id="driver1-list"></div>
          </div>
        </div>
        <div class="driver-select">
          <label>Driver 2</label>
          <div class="driver-input">
            <input type="text" id="driver2" placeholder="Type driver name..." autocomplete="off" />
            <div class="autocomplete-list" id="driver2-list"></div>
          </div>
        </div>
        <div class="driver-select">
          <label>Driver 3 (Optional)</label>
          <div class="driver-input">
            <input type="text" id="driver3" placeholder="Type driver name..." autocomplete="off" />
            <div class="autocomplete-list" id="driver3-list"></div>
          </div>
        </div>
        <div class="driver-select">
          <label>Driver 4 (Optional)</label>
          <div class="driver-input">
            <input type="text" id="driver4" placeholder="Type driver name..." autocomplete="off" />
            <div class="autocomplete-list" id="driver4-list"></div>
          </div>
        </div>
      </div>
      <button class="btn" onclick="compareDrivers()">Compare Drivers</button>
    </div>

    <div id="comparisonResults">
      <div class="no-comparison">
        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" style="opacity: 0.3; margin-bottom: 16px;">
          <path d="M9 11l3 3L22 4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <p>Select at least 2 drivers and click "Compare" to get started.</p>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script>
    let allDriverData = [];
    let driverSeasons = {};
    let qualifyingData = [];
    let chartInstance = null;

    // Load qualifying data
    fetch('qualifying_data_all_series.csv')
      .then(response => response.text())
      .then(csv => {
        const lines = csv.trim().split(/\r?\n/);
        const headers = lines[0].split(',').map(h => h.trim());
        for (let i = 1; i < lines.length; i++) {
          const values = lines[i].split(',');
          const row = {};
          headers.forEach((h, idx) => {
            row[h] = values[idx] ? values[idx].trim() : '';
          });
          qualifyingData.push(row);
        }
        console.log('Loaded qualifying data:', qualifyingData.length, 'sessions');
      })
      .catch(error => console.error('Error loading qualifying data:', error));

    // Load the CSV data
    fetch('masterdoc_with_scores.csv')
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to load CSV file');
        }
        return response.text();
      })
      .then(csv => {
        console.log('CSV loaded, parsing data...');
        const lines = csv.trim().split(/\r?\n/);
        const headers = lines[0].split(',').map(h => h.trim());
        console.log('Headers found:', headers);
        
        for (let i = 1; i < lines.length; i++) {
          const values = parseCSVLine(lines[i]);
          const row = {};
          headers.forEach((h, idx) => {
            row[h] = values[idx] ? values[idx].trim().replace(/^"|"$/g, '') : '';
          });
          
          if (row.Driver && row.Year && row.Series) {
            const key = row.Driver;
            if (!driverSeasons[key]) {
              driverSeasons[key] = [];
            }
            driverSeasons[key].push(row);
          }
        }
        
        console.log('Parsed drivers:', Object.keys(driverSeasons).length);
        populateDriverDropdowns();
      })
      .catch(error => {
        console.error('Error loading CSV:', error);
        document.getElementById('comparisonResults').innerHTML = `
          <div class="no-comparison">
            <p style="color: #ff6b6b;">Error loading driver data: ${error.message}</p>
            <p style="color: var(--muted); font-size: 13px;">Please make sure masterdoc_with_scores.csv is in the same directory.</p>
          </div>
        `;
      });

    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          result.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current);
      return result;
    }

    function populateDriverDropdowns() {
      const drivers = Object.keys(driverSeasons).sort();
      console.log('Total drivers found:', drivers.length);
      
      if (drivers.length === 0) {
        console.error('No drivers found in CSV data');
        return;
      }
      
      // Setup autocomplete for each input
      const inputs = ['driver1', 'driver2', 'driver3', 'driver4'];
      
      inputs.forEach(id => {
        const input = document.getElementById(id);
        const listEl = document.getElementById(id + '-list');
        
        input.addEventListener('input', () => {
          const query = input.value.toLowerCase().trim();
          if (!query) {
            listEl.classList.remove('active');
            return;
          }
          
          const matches = drivers.filter(d => d.toLowerCase().includes(query)).slice(0, 10);
          
          if (matches.length === 0) {
            listEl.classList.remove('active');
            return;
          }
          
          listEl.innerHTML = matches.map(driver => 
            `<div class="autocomplete-item" data-value="${driver}">${driver}</div>`
          ).join('');
          listEl.classList.add('active');
          
          // Add click handlers
          listEl.querySelectorAll('.autocomplete-item').forEach(item => {
            item.addEventListener('click', () => {
              input.value = item.dataset.value;
              input.dataset.selected = item.dataset.value;
              listEl.classList.remove('active');
            });
          });
        });
        
        // Close list when clicking outside
        document.addEventListener('click', (e) => {
          if (!input.contains(e.target) && !listEl.contains(e.target)) {
            listEl.classList.remove('active');
          }
        });
      });
      
      console.log('Autocomplete setup for', drivers.length, 'drivers');
    }

    function compareDrivers() {
      const allDrivers = Object.keys(driverSeasons);
      const selectedDrivers = [
        document.getElementById('driver1').value,
        document.getElementById('driver2').value,
        document.getElementById('driver3').value,
        document.getElementById('driver4').value
      ].filter(d => d.trim());

      if (selectedDrivers.length < 2) {
        alert('Please select at least 2 drivers to compare.');
        return;
      }
      
      // Validate driver names exist
      const invalid = selectedDrivers.filter(d => !allDrivers.includes(d));
      if (invalid.length > 0) {
        alert('Driver not found: ' + invalid.join(', ') + '\nPlease select from the autocomplete suggestions.');
        return;
      }

      const resultsDiv = document.getElementById('comparisonResults');
      resultsDiv.innerHTML = '';

      // Calculate stats for all drivers to find leaders
      const driverStats = selectedDrivers.map(driver => {
        const seasons = driverSeasons[driver];
        const scores = seasons.map(s => parseFloat(s['Age-Adjusted Score'])).filter(s => !isNaN(s));
        const avgFinishes = seasons.map(s => parseFloat(s['AVG Finish'])).filter(f => !isNaN(f));
        const taafDeltas = seasons.map(s => parseFloat(s['TAAF Delta'])).filter(t => !isNaN(t));
        
        return {
          driver,
          maxScore: scores.length ? Math.max(...scores) : -Infinity,
          avgScore: scores.length ? scores.reduce((a, b) => a + b, 0) / scores.length : -Infinity,
          avgFinish: avgFinishes.length ? avgFinishes.reduce((a, b) => a + b, 0) / avgFinishes.length : Infinity,
          avgTAAF: taafDeltas.length ? taafDeltas.reduce((a, b) => a + b, 0) / taafDeltas.length : -Infinity
        };
      });

      // Find leaders for each metric
      const leaders = {
        maxScore: driverStats.reduce((max, d) => d.maxScore > max.maxScore ? d : max).driver,
        avgScore: driverStats.reduce((max, d) => d.avgScore > max.avgScore ? d : max).driver,
        avgFinish: driverStats.reduce((min, d) => d.avgFinish < min.avgFinish ? d : min).driver, // Lower is better
        avgTAAF: driverStats.reduce((min, d) => d.avgTAAF < min.avgTAAF ? d : min).driver // Lower is better (closer to 0 or negative means dominated)
      };

      // Create comparison cards
      const cardGrid = document.createElement('div');
      cardGrid.className = 'comparison-grid';
      
      selectedDrivers.forEach(driver => {
        const seasons = driverSeasons[driver];
        const card = createDriverCard(driver, seasons, leaders);
        cardGrid.appendChild(card);
      });
      
      resultsDiv.appendChild(cardGrid);

      // Create career trajectory chart
      createCareerChart(selectedDrivers);

      // Create radar chart
      createRadarChart(selectedDrivers);

      // Create head-to-head section
      createHeadToHead(selectedDrivers);
      
      // Create qualifying head-to-head section
      createQualifyingH2H(selectedDrivers);
    }

    function createDriverCard(driver, seasons, leaders) {
      const card = document.createElement('div');
      card.className = 'driver-card';

      // Calculate aggregate stats
      const years = seasons.map(s => parseInt(s.Year)).filter(y => !isNaN(y));
      const minYear = Math.min(...years);
      const maxYear = Math.max(...years);
      
      const scores = seasons.map(s => parseFloat(s['Age-Adjusted Score'])).filter(s => !isNaN(s));
      const avgScore = scores.length ? (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(1) : 'N/A';
      const maxScore = scores.length ? Math.max(...scores).toFixed(1) : 'N/A';
      
      const avgFinishes = seasons.map(s => parseFloat(s['AVG Finish'])).filter(f => !isNaN(f));
      const avgFinish = avgFinishes.length ? (avgFinishes.reduce((a, b) => a + b, 0) / avgFinishes.length).toFixed(2) : 'N/A';
      
      const taafDeltas = seasons.map(s => parseFloat(s['TAAF Delta'])).filter(t => !isNaN(t));
      const avgTAAF = taafDeltas.length ? (taafDeltas.reduce((a, b) => a + b, 0) / taafDeltas.length).toFixed(2) : 'N/A';

      const seriesList = [...new Set(seasons.map(s => s.Series))].join(', ');
      
      // Get xPACE values (same across all seasons for a driver)
      const xPaceOval = seasons[0]['xPACE_Oval'] ? parseFloat(seasons[0]['xPACE_Oval']).toFixed(1) : 'N/A';
      const xPaceLongRoad = seasons[0]['xPACE_Long_Road'] ? parseFloat(seasons[0]['xPACE_Long_Road']).toFixed(1) : 'N/A';
      const xPaceShortRoad = seasons[0]['xPACE_Short_Road'] ? parseFloat(seasons[0]['xPACE_Short_Road']).toFixed(1) : 'N/A';
      const xPaceStreet = seasons[0]['xPACE_Street'] ? parseFloat(seasons[0]['xPACE_Street']).toFixed(1) : 'N/A';
      const indyXPace = seasons[0]['Indy_xPACE'] ? parseFloat(seasons[0]['Indy_xPACE']).toFixed(1) : 'N/A';

      // Check if this driver leads in each metric
      const isMaxScoreLeader = leaders && leaders.maxScore === driver;
      const isAvgScoreLeader = leaders && leaders.avgScore === driver;
      const isAvgFinishLeader = leaders && leaders.avgFinish === driver;
      const isAvgTAAFLeader = leaders && leaders.avgTAAF === driver;

      card.innerHTML = `
        <h2>${driver}</h2>
        <div class="seasons">${minYear}-${maxYear} • ${seasons.length} season${seasons.length > 1 ? 's' : ''}</div>
        <div class="stat-row">
          <div class="stat-label">Peak Prospect Score</div>
          <div class="stat-value ${isMaxScoreLeader ? 'best' : ''}">${maxScore}</div>
        </div>
        <div class="stat-row">
          <div class="stat-label">Avg Prospect Score</div>
          <div class="stat-value ${isAvgScoreLeader ? 'best' : ''}">${avgScore}</div>
        </div>
        <div class="stat-row">
          <div class="stat-label">Career Avg Finish</div>
          <div class="stat-value ${isAvgFinishLeader ? 'best' : ''}">${avgFinish}</div>
        </div>
        <div class="stat-row">
          <div class="stat-label">Avg TAAF Delta</div>
          <div class="stat-value ${isAvgTAAFLeader ? 'best' : ''}">${avgTAAF}</div>
        </div>
        <div class="stat-row">
          <div class="stat-label" style="font-weight: 600; color: var(--accent);">Indy-xPACE (Calendar-Weighted)</div>
          <div class="stat-value" style="font-weight: 600; color: var(--accent);">${indyXPace}</div>
        </div>
        <div class="stat-row">
          <div class="stat-label" style="font-size: 12px;">xPACE (Oval / Long / Short / Street)</div>
          <div class="stat-value" style="font-size: 12px;">${xPaceOval} / ${xPaceLongRoad} / ${xPaceShortRoad} / ${xPaceStreet}</div>
        </div>
        <div class="stat-row">
          <div class="stat-label">Series</div>
          <div class="stat-value">${seriesList}</div>
        </div>
      `;

      return card;
    }

    function createCareerChart(drivers) {
      const chartSection = document.createElement('div');
      chartSection.className = 'chart-section';
      chartSection.innerHTML = '<h3>Career Prospect Score Trajectory</h3><canvas id="careerChart"></canvas>';
      document.getElementById('comparisonResults').appendChild(chartSection);

      const datasets = drivers.map((driver, idx) => {
        const seasons = driverSeasons[driver];
        // Sort by year first
        const sortedSeasons = seasons.slice().sort((a, b) => parseInt(a.Year) - parseInt(b.Year));
        // Map to career year (1, 2, 3, etc.)
        const data = sortedSeasons.map((s, careerYear) => ({
          x: careerYear + 1,
          y: parseFloat(s['Age-Adjusted Score']) || 0
        }));

        const colors = ['#3dd6c1', '#5a8fff', '#ff6b9d', '#ffd93d'];
        return {
          label: driver,
          data: data,
          borderColor: colors[idx % colors.length],
          backgroundColor: colors[idx % colors.length] + '40',
          tension: 0.3,
          pointRadius: 5,
          pointHoverRadius: 7
        };
      });

      const ctx = document.getElementById('careerChart').getContext('2d');
      if (chartInstance) {
        chartInstance.destroy();
      }
      
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 2.5,
          plugins: {
            legend: {
              labels: { color: '#f2f5ff', font: { size: 13 } }
            }
          },
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: 'Career Year in USF Pro Championships', color: '#9aa3b5' },
              ticks: { color: '#9aa3b5', stepSize: 1 },
              grid: { color: '#1f2534' }
            },
            y: {
              title: { display: true, text: 'Prospect Score', color: '#9aa3b5' },
              ticks: { color: '#9aa3b5' },
              grid: { color: '#1f2534' }
            }
          }
        }
      });
    }

    function createRadarChart(drivers) {
      const chartSection = document.createElement('div');
      chartSection.className = 'chart-section';
      chartSection.innerHTML = `
        <h3>Multi-Dimensional Comparison</h3>
        <div class="radar-container"><canvas id="radarChart"></canvas></div>
        <div class="metric-explainer">
          <h4>Metric Explanations (0-100 scale):</h4>
          <ul>
            <li><strong>Avg Score:</strong> Average Age-Adjusted Prospect Score across all seasons (raw value, not percentile)</li>
            <li><strong>Peak Score:</strong> Highest Age-Adjusted Prospect Score achieved in any season (raw value)</li>
            <li><strong>Avg Finish:</strong> Career average finish position normalized to 0-100 (lower finish = higher score)</li>
            <li><strong>TAAF Delta:</strong> Average teammate performance differential, normalized to 0-100 (negative delta = outperformed teammates consistently)</li>
            <li><strong>Consistency:</strong> Score variation across seasons (higher = more consistent performance)</li>
          </ul>
        </div>
      `;
      document.getElementById('comparisonResults').appendChild(chartSection);

      const datasets = drivers.map((driver, idx) => {
        const seasons = driverSeasons[driver];
        
        // Calculate normalized metrics (0-100 scale)
        const scores = seasons.map(s => parseFloat(s['Age-Adjusted Score'])).filter(s => !isNaN(s));
        const avgScore = scores.length ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
        
        const avgFinishes = seasons.map(s => parseFloat(s['AVG Finish'])).filter(f => !isNaN(f));
        const avgFinish = avgFinishes.length ? avgFinishes.reduce((a, b) => a + b, 0) / avgFinishes.length : 10;
        const finishScore = Math.max(0, 100 - (avgFinish * 10)); // Lower finish = higher score
        
        const taafDeltas = seasons.map(s => parseFloat(s['TAAF Delta'])).filter(t => !isNaN(t));
        const avgTAAF = taafDeltas.length ? taafDeltas.reduce((a, b) => a + b, 0) / taafDeltas.length : 0;
        const taafScore = Math.min(100, Math.max(0, 50 + (avgTAAF * 10)));
        
        const peakScore = scores.length ? Math.max(...scores) : 0;
        const consistency = scores.length > 1 ? (1 - (standardDeviation(scores) / 20)) * 100 : 50;

        const colors = ['#3dd6c1', '#5a8fff', '#ff6b9d', '#ffd93d'];
        return {
          label: driver,
          data: [avgScore, peakScore, finishScore, taafScore, consistency],
          borderColor: colors[idx % colors.length],
          backgroundColor: colors[idx % colors.length] + '40',
          pointRadius: 4,
          pointHoverRadius: 6
        };
      });

      const ctx = document.getElementById('radarChart').getContext('2d');
      new Chart(ctx, {
        type: 'radar',
        data: {
          labels: ['Avg Score', 'Peak Score', 'Avg Finish', 'TAAF Delta', 'Consistency'],
          datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 1.5,
          plugins: {
            legend: {
              labels: { color: '#f2f5ff', font: { size: 13 } }
            }
          },
          scales: {
            r: {
              min: 0,
              max: 100,
              ticks: { color: '#9aa3b5', backdropColor: 'transparent' },
              grid: { color: '#1f2534' },
              pointLabels: { color: '#9aa3b5', font: { size: 12 } }
            }
          }
        }
      });
    }

    function standardDeviation(values) {
      const avg = values.reduce((a, b) => a + b, 0) / values.length;
      const squareDiffs = values.map(value => Math.pow(value - avg, 2));
      const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
      return Math.sqrt(avgSquareDiff);
    }

    function createHeadToHead(drivers) {
      const h2hSection = document.createElement('div');
      h2hSection.className = 'h2h-section';
      h2hSection.innerHTML = `
        <h3>Head-to-Head Matchups (When Teammates)</h3>
        <p style="color: var(--muted); font-size: 13px; margin-bottom: 16px;">Comparing Age-Adjusted Prospect Scores when drivers were on the same team in the same season. Higher score indicates better overall performance that year.</p>
        <div class="h2h-grid" id="h2hGrid"></div>
      `;
      document.getElementById('comparisonResults').appendChild(h2hSection);

      const grid = document.getElementById('h2hGrid');
      let foundMatchup = false;

      // Find years where any two drivers were teammates
      for (let i = 0; i < drivers.length; i++) {
        for (let j = i + 1; j < drivers.length; j++) {
          const driver1 = drivers[i];
          const driver2 = drivers[j];
          
          const seasons1 = driverSeasons[driver1];
          const seasons2 = driverSeasons[driver2];
          
          seasons1.forEach(s1 => {
            const matchingSeason = seasons2.find(s2 => 
              s2.Year === s1.Year && 
              s2.Series === s1.Series && 
              s2.Team === s1.Team
            );
            
            if (matchingSeason) {
              foundMatchup = true;
              const item = document.createElement('div');
              item.className = 'h2h-item';
              
              const score1 = parseFloat(s1['Age-Adjusted Score']) || 0;
              const score2 = parseFloat(matchingSeason['Age-Adjusted Score']) || 0;
              const winner = score1 > score2 ? driver1 : driver2;
              
              item.innerHTML = `
                <div class="year">${s1.Year} ${s1.Series} • ${s1.Team}</div>
                <div class="matchup">
                  <div class="driver-name ${winner === driver1 ? 'winner' : ''}">${driver1}: ${score1.toFixed(1)}</div>
                  <div>vs</div>
                  <div class="driver-name ${winner === driver2 ? 'winner' : ''}">${driver2}: ${score2.toFixed(1)}</div>
                </div>
              `;
              grid.appendChild(item);
            }
          });
        }
      }

      if (!foundMatchup) {
        grid.innerHTML = '<p style="color: var(--muted); text-align: center; padding: 20px;">No seasons found where these drivers were teammates.</p>';
      }
    }

    function createQualifyingH2H(drivers) {
      if (qualifyingData.length === 0) {
        return; // Qualifying data not loaded yet
      }

      const h2hSection = document.createElement('div');
      h2hSection.className = 'h2h-section';
      h2hSection.style.marginTop = '32px';
      h2hSection.innerHTML = `
        <h3>Qualifying Head-to-Head (When Teammates)</h3>
        <p style="color: var(--muted); font-size: 13px; margin-bottom: 16px;">Comparing qualifying performance when drivers were on the same team. Shows who outqualified who in each session.</p>
        <div class="h2h-grid" id="qualH2HGrid"></div>
      `;
      document.getElementById('comparisonResults').appendChild(h2hSection);

      const grid = document.getElementById('qualH2HGrid');
      let foundMatchup = false;

      // Group qualifying by unique session
      const sessionMap = {};
      qualifyingData.forEach(q => {
        const key = `${q.series}_${q.year}_${q.track}_${q.qualifying_session}`;
        if (!sessionMap[key]) {
          sessionMap[key] = {
            series: q.series,
            year: q.year,
            track: q.track,
            session: q.qualifying_session,
            results: []
          };
        }
        sessionMap[key].results.push(q);
      });

      // Find sessions where drivers were teammates
      const matchups = {};
      
      for (let i = 0; i < drivers.length; i++) {
        for (let j = i + 1; j < drivers.length; j++) {
          const driver1 = drivers[i];
          const driver2 = drivers[j];
          const pairKey = [driver1, driver2].sort().join('_vs_');
          
          if (!matchups[pairKey]) {
            matchups[pairKey] = {
              driver1,
              driver2,
              sessions: [],
              driver1Wins: 0,
              driver2Wins: 0
            };
          }

          Object.values(sessionMap).forEach(session => {
            const d1Result = session.results.find(r => r.driver === driver1);
            const d2Result = session.results.find(r => r.driver === driver2);
            
            if (d1Result && d2Result && d1Result.team === d2Result.team) {
              foundMatchup = true;
              const d1Time = parseFloat(d1Result.best_lap_time);
              const d2Time = parseFloat(d2Result.best_lap_time);
              
              if (!isNaN(d1Time) && !isNaN(d2Time)) {
                const winner = d1Time < d2Time ? driver1 : driver2;
                if (winner === driver1) matchups[pairKey].driver1Wins++;
                else matchups[pairKey].driver2Wins++;
                
                matchups[pairKey].sessions.push({
                  year: session.year,
                  series: session.series,
                  track: session.track,
                  team: d1Result.team,
                  winner,
                  d1Time,
                  d2Time,
                  gap: Math.abs(d1Time - d2Time).toFixed(3)
                });
              }
            }
          });
        }
      }

      // Display matchups
      Object.values(matchups).forEach(matchup => {
        if (matchup.sessions.length > 0) {
          const item = document.createElement('div');
          item.className = 'h2h-item';
          item.style.marginBottom = '20px';
          
          item.innerHTML = `
            <div class="year" style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">
              ${matchup.driver1} vs ${matchup.driver2}
            </div>
            <div style="color: var(--accent); font-size: 14px; margin-bottom: 12px;">
              H2H: ${matchup.driver1} ${matchup.driver1Wins} - ${matchup.driver2Wins} ${matchup.driver2}
            </div>
            ${matchup.sessions.map(s => `
              <div style="padding: 8px 0; border-bottom: 1px solid var(--border);">
                <div style="font-size: 13px; color: var(--muted); margin-bottom: 4px;">
                  ${s.year} ${s.series} • ${s.track} • ${s.team}
                </div>
                <div style="font-size: 14px;">
                  <span style="color: ${s.winner === matchup.driver1 ? 'var(--accent)' : 'var(--text)'}; font-weight: ${s.winner === matchup.driver1 ? '600' : '400'}">
                    ${matchup.driver1}: ${s.d1Time.toFixed(3)}s
                  </span>
                  <span style="color: var(--muted); margin: 0 8px;">vs</span>
                  <span style="color: ${s.winner === matchup.driver2 ? 'var(--accent)' : 'var(--text)'}; font-weight: ${s.winner === matchup.driver2 ? '600' : '400'}">
                    ${matchup.driver2}: ${s.d2Time.toFixed(3)}s
                  </span>
                  <span style="color: var(--muted); margin-left: 8px;">(Δ ${s.gap}s)</span>
                </div>
              </div>
            `).join('')}
          `;
          grid.appendChild(item);
        }
      });

      if (!foundMatchup) {
        grid.innerHTML = '<div class="no-comparison">No qualifying sessions found where these drivers were teammates.</div>';
      }
    }
  </script>
</body>
</html>
