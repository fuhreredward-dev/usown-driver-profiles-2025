<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Driver Prospect Profiles</title>
  <style>
    :root {
      --bg: #0b0d12;
      --panel: #121622;
      --panel-2: #0f1320;
      --accent: #3dd6c1;
      --accent-soft: rgba(61, 214, 193, 0.15);
      --text: #f2f5ff;
      --muted: #9aa3b5;
      --border: #1f2534;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --font: "Manrope", "Segoe UI", sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--font);
      background: radial-gradient(120% 120% at 10% 10%, #101527 0%, #080a0f 55%);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      padding: 24px 28px 12px;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    h1 { margin: 0; letter-spacing: -0.01em; font-weight: 700; font-size: 28px; }
    .tagline { color: var(--muted); font-size: 14px; margin-top: 4px; }
    .controls { display: flex; gap: 10px; flex-wrap: wrap; }
    input, select {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      min-width: 200px;
      outline: none;
    }
    input:focus, select:focus { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent-soft); }
    main { display: grid; grid-template-columns: 320px 1fr; gap: 14px; padding: 0 28px 28px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
    }
    #driverList { padding: 12px; max-height: calc(100vh - 140px); overflow-y: auto; }
    .driver-card {
      padding: 12px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      border: 1px solid transparent;
    }
    .driver-card:hover { transform: translateY(-1px); border-color: var(--accent); background: var(--accent-soft); }
    .driver-card.active { border-color: var(--accent); background: var(--accent-soft); }
    .driver-name { font-weight: 700; margin: 0; }
    .driver-meta { color: var(--muted); font-size: 13px; margin-top: 2px; }
    .chip { display: inline-block; padding: 4px 8px; border-radius: 999px; font-size: 12px; background: var(--panel-2); border: 1px solid var(--border); margin-right: 6px; }
    #detail { padding: 18px; display: grid; gap: 14px; }
    .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; }
    .stat { background: var(--panel-2); border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
    .stat label { display: block; color: var(--muted); font-size: 12px; margin-bottom: 6px; letter-spacing: 0.02em; }
    .stat .value { font-size: 20px; font-weight: 700; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 8px 10px; text-align: left; border-bottom: 1px solid var(--border); }
    th { color: var(--muted); font-weight: 600; letter-spacing: 0.01em; }
    tr:last-child td { border-bottom: none; }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: var(--accent-soft); color: var(--text); font-size: 12px; border: 1px solid var(--accent); }
    .muted { color: var(--muted); }
    .section-title { margin: 0 0 4px; font-size: 16px; }
    .similar { display: grid; gap: 8px; }
    .similar-card { background: var(--panel-2); border: 1px solid var(--border); border-radius: 12px; padding: 10px; cursor: pointer; transition: transform 120ms ease, border-color 120ms ease; }
    .similar-card:hover { transform: translateY(-1px); border-color: var(--accent); }
    .small { font-size: 12px; color: var(--muted); }
    .banner { background: linear-gradient(120deg, rgba(61, 214, 193, 0.2), rgba(61, 214, 193, 0.05)); border: 1px solid var(--border); border-radius: 12px; padding: 10px 12px; font-size: 13px; }
    .summary { font-size: 14px; color: var(--muted); line-height: 1.45; }
    .topnav {
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      padding: 12px 28px;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    .topnav a {
      color: var(--muted);
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      padding: 8px 12px;
      border-radius: 8px;
      transition: all 120ms ease;
    }
    .topnav a:hover {
      color: var(--accent);
      background: var(--accent-soft);
    }
    .topnav a.active {
      color: var(--accent);
      background: var(--accent-soft);
      border: 1px solid var(--accent);
    }
    .brand-header {
      background: var(--panel-2);
      border-bottom: 1px solid var(--border);
      padding: 24px 28px 16px;
      text-align: center;
    }
    .brand-title {
      font-size: 32px;
      font-weight: 700;
      margin: 0 0 8px;
      letter-spacing: -0.02em;
    }
    .brand-subtitle {
      color: var(--muted);
      font-size: 15px;
      margin: 0 0 12px;
      line-height: 1.5;
    }
    .brand-links {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
      font-size: 13px;
    }
    .brand-links a {
      color: var(--accent);
      text-decoration: none;
      transition: opacity 120ms ease;
    }
    .brand-links a:hover {
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <nav class="topnav">
    <a href="index.html" class="active">Driver Profiles</a>
    <a href="masterdoc_table.html">Data Table</a>
    <a href="statistics_guide.html">Statistics Guide</a>
  </nav>
  
  <div class="brand-header">
    <h1 class="brand-title">ScoutDeck presented by USOpenWheelNation</h1>
    <p class="brand-subtitle">An analysis of IndyCar prospects utilizing USF Pro Championships race results from 2015-2025.</p>
    <div class="brand-links">
      <a href="https://usopenWheelNation.com" target="_blank" rel="noopener">Visit USOpenWheelNation.com →</a>
      <span style="color: var(--muted);">•</span>
      <a href="mailto:fuhreredward@gmail.com">Contact: fuhreredward@gmail.com</a>
    </div>
  </div>
  
  <header>
    <div>
      <h1>Driver Prospect Profiles</h1>
      <div class="tagline">Interactive view backed by over 7,000 USF Pro Championships race results. Click a driver to see their seasons, scores, and comps.</div>
    </div>
    <div class="controls">
      <input id="search" placeholder="Search driver (e.g., Askew)" />
      <select id="seriesFilter">
        <option value="">All series</option>
      </select>
      <select id="yearFilter">
        <option value="">All years</option>
      </select>
    </div>
  </header>

  <main>
    <aside id="driverList" class="panel"></aside>
    <section id="detail" class="panel">
      <div class="banner">Loading data…</div>
    </section>
  </main>

  <script>
    const CSV_URL = 'masterdoc_with_scores.csv';

    const numberFields = new Set([
      'Age', 'Year', 'AVG Finish', 'TAAF Delta', 'AF YoY Change', 'TAAF Delta YoY Change',
      'Series-Adj AVG Finish', 'Series-Adj TAAF Delta', 'Prospect Score', 'Age Adjustment', 'Age-Adjusted Score'
    ]);

    const toNumber = (value) => {
      const n = parseFloat(value);
      return Number.isFinite(n) ? n : null;
    };

    function parseCSV(text) {
      const lines = text.trim().split(/\r?\n/);
      const headers = lines.shift().split(',').map(h => h.trim());
      return lines.map(line => {
        const cols = line.split(',');
        const row = {};
        headers.forEach((h, i) => {
          const raw = (cols[i] ?? '').trim();
          row[h] = numberFields.has(h) ? toNumber(raw) : raw;
        });
        return row;
      });
    }

    function buildDrivers(rows) {
      const map = new Map();
      rows.forEach(r => {
        const name = (r['Driver'] || '').trim();
        if (!name) return;
        const season = {
          year: r['Year'],
          age: r['Age'],
          series: r['Series'],
          team: r['Team'],
          avgFinish: r['AVG Finish'],
          taafDelta: r['TAAF Delta'],
          avgFinishYoY: r['AF YoY Change'],
          taafDeltaYoY: r['TAAF Delta YoY Change'],
          advancedNXT: (r['Advanced to Indy NXT'] || '').toLowerCase() === 'yes',
          advancedIndyCar: (r['Advanced to IndyCar'] || '').toLowerCase() === 'yes',
          seriesAdjAvgFinish: r['Series-Adj AVG Finish'],
          seriesAdjDelta: r['Series-Adj TAAF Delta'],
          prospectScore: r['Prospect Score'],
          ageAdjustment: r['Age Adjustment'],
          ageAdjustedScore: r['Age-Adjusted Score']
        };
        const existing = map.get(name) || { name, seasons: [] };
        existing.seasons.push(season);
        map.set(name, existing);
      });

      map.forEach(driver => {
        driver.seasons.sort((a, b) => (b.year || 0) - (a.year || 0));
        const scores = driver.seasons.map(s => s.ageAdjustedScore).filter(Boolean);
        const bestScore = scores.length ? Math.max(...scores) : null;
        const meanScore = scores.length ? (scores.reduce((a, b) => a + b, 0) / scores.length) : null;
        const latest = driver.seasons[0];
        const minAdjAvg = driver.seasons
          .map(s => s.seriesAdjAvgFinish)
          .filter(Number.isFinite)
          .reduce((m, v) => (m === null ? v : Math.min(m, v)), null);

        driver.metrics = {
          bestScore,
          meanScore,
          latestScore: latest?.ageAdjustedScore ?? null,
          latestYear: latest?.year ?? null,
          latestSeries: latest?.series ?? '',
          latestTeam: latest?.team ?? '',
          latestAge: latest?.age ?? null,
          currentAge: (latest?.age && latest?.year) ? latest.age + (2026 - latest.year) : null,
          minAdjAvg,
          rank2025: {},
          taafPercentiles: {}
        };
      });

      return map;
    }

    function computeSeriesRanks(drivers) {
      const buckets = new Map();
      drivers.forEach(d => {
        d.seasons.forEach(s => {
          if (s.year !== 2025 || !Number.isFinite(s.ageAdjustedScore) || !s.series) return;
          const list = buckets.get(s.series) || [];
          list.push({ driver: d, score: s.ageAdjustedScore });
          buckets.set(s.series, list);
        });
      });

      buckets.forEach((list, series) => {
        list.sort((a, b) => b.score - a.score);
        list.forEach((entry, idx) => {
          entry.driver.metrics.rank2025[series] = idx + 1;
        });
      });
    }

    function computeTAAFPercentiles(drivers) {
      // Collect all TAAF delta values by series and by year
      const bySeries = new Map();
      const byYear = new Map();
      
      drivers.forEach(d => {
        d.seasons.forEach(s => {
          if (!Number.isFinite(s.taafDelta) || !s.series || !s.year) return;
          
          // By series (career best)
          const seriesList = bySeries.get(s.series) || [];
          seriesList.push({ driver: d, season: s, taafDelta: s.taafDelta });
          bySeries.set(s.series, seriesList);
          
          // By year
          const yearList = byYear.get(s.year) || [];
          yearList.push({ driver: d, season: s, taafDelta: s.taafDelta });
          byYear.set(s.year, yearList);
        });
      });

      // Calculate percentiles for each driver by series (using their best TAAF delta)
      bySeries.forEach((list, series) => {
        const sortedDeltas = list.map(x => x.taafDelta).sort((a, b) => a - b);
        const driverBest = new Map();
        
        // Get best (most negative) TAAF delta per driver in this series
        list.forEach(entry => {
          const current = driverBest.get(entry.driver.name);
          if (!current || entry.taafDelta < current) {
            driverBest.set(entry.driver.name, entry.taafDelta);
          }
        });
        
        // Calculate percentile for each driver's best
        driverBest.forEach((bestDelta, driverName) => {
          const driver = drivers.get(driverName);
          if (!driver) return;
          const percentile = (sortedDeltas.filter(d => d > bestDelta).length / sortedDeltas.length) * 100;
          if (!driver.metrics.taafPercentiles.bySeries) driver.metrics.taafPercentiles.bySeries = {};
          driver.metrics.taafPercentiles.bySeries[series] = Math.round(percentile);
        });
      });

      // Calculate percentiles by specific year
      drivers.forEach(d => {
        d.seasons.forEach(s => {
          if (!Number.isFinite(s.taafDelta) || !s.year) return;
          const yearList = byYear.get(s.year);
          if (!yearList) return;
          const sortedDeltas = yearList.map(x => x.taafDelta).sort((a, b) => a - b);
          const percentile = (sortedDeltas.filter(delta => delta > s.taafDelta).length / sortedDeltas.length) * 100;
          if (!d.metrics.taafPercentiles.byYear) d.metrics.taafPercentiles.byYear = {};
          d.metrics.taafPercentiles.byYear[s.year] = Math.round(percentile);
        });
      });
    }

    function distance(a, b) {
      const dims = ['bestScore', 'meanScore', 'latestScore', 'minAdjAvg'];
      let sum = 0;
      let count = 0;
      dims.forEach(key => {
        const va = a.metrics[key];
        const vb = b.metrics[key];
        if (Number.isFinite(va) && Number.isFinite(vb)) {
          const d = va - vb;
          sum += d * d;
          count += 1;
        }
      });
      if (!count) return Infinity;
      return Math.sqrt(sum / count);
    }

    function computeSimilarities(target, drivers) {
      const list = Array.from(drivers.values())
        .filter(d => d.name !== target.name)
        .map(d => ({ driver: d, dist: distance(target, d) }))
        .filter(x => Number.isFinite(x.dist))
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 5);
      return list;
    }

    function formatNumber(n, digits = 1) {
      return Number.isFinite(n) ? n.toFixed(digits) : '–';
    }

    function getScoreColor(score) {
      if (!Number.isFinite(score)) return '#7d8590';
      if (score >= 90) return '#1a7f37';
      if (score >= 80) return '#2ea043';
      if (score >= 70) return '#4ac26b';
      if (score >= 60) return '#d4a72c';
      return '#7d8590';
    }

    function renderDriverList(drivers, { query = '', series = '', year = '' } = {}) {
      const listEl = document.getElementById('driverList');
      listEl.innerHTML = '';
      const normalizedQuery = query.toLowerCase();

      const rows = Array.from(drivers.values())
        .filter(d => !normalizedQuery || d.name.toLowerCase().includes(normalizedQuery))
        .filter(d => !series || d.seasons.some(s => s.series === series))
        .filter(d => !year || d.seasons.some(s => String(s.year) === year))
        .sort((a, b) => (b.metrics.bestScore || 0) - (a.metrics.bestScore || 0));

      rows.forEach(d => {
        const card = document.createElement('div');
        card.className = 'driver-card';
        card.dataset.name = d.name;
        card.innerHTML = `
          <div class="driver-name">${d.name}</div>
          <div class="driver-meta">Best score ${formatNumber(d.metrics.bestScore, 1)} · Latest ${d.metrics.latestSeries || '—'} ${d.metrics.latestYear || ''}</div>
        `;
        card.addEventListener('click', () => selectDriver(d.name));
        listEl.appendChild(card);
      });

      if (!rows.length) {
        const empty = document.createElement('div');
        empty.className = 'driver-meta';
        empty.textContent = 'No drivers match your filters yet.';
        listEl.appendChild(empty);
      }
    }

    function generateTAAFInsights(driver) {
      const insights = [];
      
      // Career best by series
      if (driver.metrics.taafPercentiles.bySeries) {
        Object.entries(driver.metrics.taafPercentiles.bySeries).forEach(([series, percentile]) => {
          if (percentile > 0) {
            insights.push(`${driver.name} outperforms their teammates better than ${percentile}% of drivers in ${series} from 2015-2025`);
          }
        });
      }
      
      // Latest year performance
      const latest = driver.seasons[0];
      if (latest && latest.year && driver.metrics.taafPercentiles.byYear && driver.metrics.taafPercentiles.byYear[latest.year]) {
        const yearPercentile = driver.metrics.taafPercentiles.byYear[latest.year];
        if (yearPercentile > 0 && Number.isFinite(latest.taafDelta)) {
          insights.push(`${driver.name} outperformed their teammates better than ${yearPercentile}% of drivers in ${latest.year}`);
        }
      }
      
      if (insights.length === 0) return '';
      return `<div class="banner" style="margin-bottom:8px;">${insights.join(' · ')}</div>`;
    }

    function summarizeDriver(driver) {
      const latest = driver.seasons[0];
      const prev = driver.seasons[1];
      const deltas = [];
      if (latest && prev && Number.isFinite(latest.ageAdjustedScore) && Number.isFinite(prev.ageAdjustedScore)) {
        const diff = latest.ageAdjustedScore - prev.ageAdjustedScore;
        deltas.push(diff > 0 ? `up ${formatNumber(diff, 1)} vs prior season` : `down ${formatNumber(Math.abs(diff), 1)} vs prior season`);
      }
      const best = driver.metrics.bestScore ? `Best score ${formatNumber(driver.metrics.bestScore, 1)}` : '';
      const adj = Number.isFinite(driver.metrics.minAdjAvg) ? `best series-adjusted avg finish ${formatNumber(driver.metrics.minAdjAvg, 2)}` : '';
      const advancement = driver.seasons.some(s => s.advancedIndyCar) ? 'Reached IndyCar' : driver.seasons.some(s => s.advancedNXT) ? 'Reached Indy NXT' : '';
      const pieces = [
        latest ? `Latest ${latest.series || 'series'} ${latest.year || ''} with ${latest.team || 'team'}` : '',
        best,
        adj,
        deltas.join(' '),
        advancement
      ].filter(Boolean);
      return pieces.join(' · ');
    }

    function renderDetail(driver, drivers) {
      const el = document.getElementById('detail');
      if (!driver) {
        el.innerHTML = '<div class="banner">Select a driver to view their profile.</div>';
        return;
      }

      const similar = computeSimilarities(driver, drivers);
      const latest = driver.seasons[0];
      const rank = latest?.series ? driver.metrics.rank2025[latest.series] : null;

      el.innerHTML = `
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
          <h2 style="margin:0;">${driver.name}</h2>
          ${latest ? `<span class="pill">Latest: ${latest.series || '—'} ${latest.year || ''}</span>` : ''}
          ${rank ? `<span class="pill">2025 ${latest.series} rank #${rank}</span>` : ''}
        </div>
        <div class="summary">${summarizeDriver(driver) || 'No summary available yet.'}</div>
        ${generateTAAFInsights(driver)}
        <div class="stat-grid">
          <div class="stat"><label>IndyCar prospect score</label><div class="value" style="color:${getScoreColor(driver.metrics.bestScore)}">${formatNumber(driver.metrics.bestScore, 1)}</div></div>
          <div class="stat"><label>Latest age-adjusted score</label><div class="value">${formatNumber(driver.metrics.latestScore, 1)}</div></div>
          <div class="stat"><label>Mean score</label><div class="value">${formatNumber(driver.metrics.meanScore, 1)}</div></div>
          <div class="stat"><label>Best series-adj avg finish</label><div class="value">${formatNumber(driver.metrics.minAdjAvg, 2)}</div></div>
          <div class="stat"><label>Latest team</label><div class="value">${driver.metrics.latestTeam || '—'}</div></div>
          <div class="stat"><label>Age as of 1/1/2026</label><div class="value">${driver.metrics.currentAge ?? '—'}</div></div>
          ${rank ? `<div class="stat"><label>2025 ${latest.series} rank</label><div class="value">#${rank}</div></div>` : ''}
        </div>

        <div>
          <h3 class="section-title">Seasons</h3>
          <table>
            <thead>
              <tr><th>Year</th><th>Series</th><th>Team</th><th>Age</th><th>Adj Avg Finish</th><th>Age-Adjusted Score</th><th>Adv.</th></tr>
            </thead>
            <tbody>
              ${driver.seasons.map(s => `
                <tr>
                  <td>${s.year ?? '—'}</td>
                  <td>${s.series || '—'}</td>
                  <td>${s.team || '—'}</td>
                  <td>${s.age ?? '—'}</td>
                  <td>${formatNumber(s.seriesAdjAvgFinish, 2)}</td>
                  <td>${formatNumber(s.ageAdjustedScore, 1)}</td>
                  <td class="small">${s.advancedIndyCar ? 'IndyCar' : s.advancedNXT ? 'Indy NXT' : ''}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <div>
          <h3 class="section-title">Comparable drivers</h3>
          <div class="similar">
            ${similar.length ? similar.map(s => `
              <div class="similar-card" data-driver="${s.driver.name}">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                  <div><strong>${s.driver.name}</strong><div class="small">Latest ${s.driver.metrics.latestSeries || '—'} ${s.driver.metrics.latestYear || ''}</div></div>
                  <div class="pill">Δ ${formatNumber(s.dist, 2)}</div>
                </div>
                <div class="small">Best ${formatNumber(s.driver.metrics.bestScore, 1)} · Mean ${formatNumber(s.driver.metrics.meanScore, 1)} · Best adj finish ${formatNumber(s.driver.metrics.minAdjAvg, 2)}</div>
              </div>
            `).join('') : '<div class="muted">Not enough data for comps.</div>'}
          </div>
        </div>
      `;

      // Add click handlers to comparable drivers
      document.querySelectorAll('.similar-card[data-driver]').forEach(card => {
        card.addEventListener('click', () => selectDriver(card.dataset.driver));
      });

      document.querySelectorAll('.driver-card').forEach(card => {
        card.classList.toggle('active', card.dataset.name === driver.name);
      });
    }

    let drivers = new Map();
    let activeDriver = null;

    function selectDriver(name) {
      activeDriver = drivers.get(name) || null;
      renderDetail(activeDriver, drivers);
    }

    function populateSeriesFilter(drivers) {
      const select = document.getElementById('seriesFilter');
      const allSeries = new Set();
      drivers.forEach(d => d.seasons.forEach(s => s.series && allSeries.add(s.series)));
      Array.from(allSeries).sort().forEach(series => {
        const opt = document.createElement('option');
        opt.value = series;
        opt.textContent = series;
        select.appendChild(opt);
      });
    }

    function populateYearFilter(drivers) {
      const select = document.getElementById('yearFilter');
      const allYears = new Set();
      drivers.forEach(d => d.seasons.forEach(s => s.year && allYears.add(s.year)));
      Array.from(allYears).sort((a, b) => b - a).forEach(year => {
        const opt = document.createElement('option');
        opt.value = year;
        opt.textContent = year;
        select.appendChild(opt);
      });
    }

    async function init() {
      const detail = document.getElementById('detail');
      try {
        const text = await fetch(CSV_URL).then(res => {
          if (!res.ok) throw new Error('Fetch failed');
          return res.text();
        });
        const rows = parseCSV(text);
        drivers = buildDrivers(rows);
        computeSeriesRanks(drivers);
        computeTAAFPercentiles(drivers);
        populateSeriesFilter(drivers);
        populateYearFilter(drivers);
        renderDriverList(drivers);
        const first = Array.from(drivers.values())[0];
        selectDriver(first?.name);
      } catch (err) {
        console.error(err);
        detail.innerHTML = '<div class="banner">Could not load masterdoc_with_scores.csv. Ensure this HTML sits next to the CSV and open via a local server (file:// may block fetch in some browsers).</div>';
      }
    }

    document.getElementById('search').addEventListener('input', (e) => {
      renderDriverList(drivers, { query: e.target.value, series: document.getElementById('seriesFilter').value, year: document.getElementById('yearFilter').value });
    });
    document.getElementById('seriesFilter').addEventListener('change', (e) => {
      renderDriverList(drivers, { query: document.getElementById('search').value, series: e.target.value, year: document.getElementById('yearFilter').value });
    });
    document.getElementById('yearFilter').addEventListener('change', (e) => {
      renderDriverList(drivers, { query: document.getElementById('search').value, series: document.getElementById('seriesFilter').value, year: e.target.value });
    });

    init();
  </script>
</body>
</html>
